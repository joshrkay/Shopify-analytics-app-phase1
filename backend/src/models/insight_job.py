"""
Insight generation job model for scheduling.

Tracks AI insight generation job execution with:
- Tenant isolation via TenantScopedMixin
- Status tracking (queued|running|failed|success|skipped)
- Cadence support (daily|hourly)
- Generation results tracking

Follows the same pattern as IngestionJob but for AI insight generation.

SECURITY: tenant_id is ONLY extracted from JWT, never from client input.

Story 8.1 - AI Insight Generation (Read-Only Analytics)
"""

import enum
import uuid
from datetime import datetime, timezone

from sqlalchemy import (
    Column,
    String,
    Integer,
    Enum,
    DateTime,
    Text,
    Index,
    JSON,
)
from sqlalchemy.dialects.postgresql import JSONB

from src.db_base import Base
from src.models.base import TimestampMixin, TenantScopedMixin


# Use JSONB for PostgreSQL, JSON for other databases (testing)
JSONType = JSON().with_variant(JSONB(), "postgresql")


class InsightJobStatus(str, enum.Enum):
    """Insight job status enumeration."""
    QUEUED = "queued"
    RUNNING = "running"
    FAILED = "failed"
    SUCCESS = "success"
    SKIPPED = "skipped"  # Skipped due to no data or entitlements


class InsightJobCadence(str, enum.Enum):
    """Cadence for insight generation."""
    DAILY = "daily"
    HOURLY = "hourly"


class InsightJob(Base, TimestampMixin, TenantScopedMixin):
    """
    Tracks insight generation job execution.

    Jobs are created by cron trigger based on tenant entitlements.
    Daily for standard plans, hourly for enterprise.

    SECURITY: tenant_id from TenantScopedMixin ensures isolation.
    tenant_id is ONLY extracted from JWT, never from client input.
    """

    __tablename__ = "insight_jobs"

    job_id = Column(
        String(255),
        primary_key=True,
        default=lambda: str(uuid.uuid4()),
        comment="Primary key (UUID)"
    )

    # Cadence
    cadence = Column(
        Enum(InsightJobCadence),
        nullable=False,
        default=InsightJobCadence.DAILY,
        comment="Job cadence: daily or hourly"
    )

    # Status tracking
    status = Column(
        Enum(InsightJobStatus),
        default=InsightJobStatus.QUEUED,
        nullable=False,
        index=True,
        comment="Job status: queued, running, failed, success, skipped"
    )

    # Results
    insights_generated = Column(
        Integer,
        default=0,
        nullable=False,
        comment="Number of insights generated by this job"
    )

    # Timing
    started_at = Column(
        DateTime(timezone=True),
        nullable=True,
        comment="When job started running"
    )

    completed_at = Column(
        DateTime(timezone=True),
        nullable=True,
        comment="When job completed (success, failed, or skipped)"
    )

    # Error tracking
    error_message = Column(
        Text,
        nullable=True,
        comment="Error message if job failed"
    )

    # Job metadata
    job_metadata = Column(
        JSONType,
        nullable=True,
        default=dict,
        comment="Additional metadata (periods analyzed, etc.)"
    )

    # Table constraints and indexes
    __table_args__ = (
        # Composite index for tenant-scoped status queries
        Index("ix_insight_jobs_tenant_status", "tenant_id", "status"),
        # Index for finding recent jobs by tenant
        Index(
            "ix_insight_jobs_tenant_created",
            "tenant_id",
            "created_at",
            postgresql_ops={"created_at": "DESC"}
        ),
        # Partial unique index: only ONE queued/running job per tenant
        Index(
            "ix_insight_jobs_active_unique",
            "tenant_id",
            unique=True,
            postgresql_where=(status.in_([InsightJobStatus.QUEUED, InsightJobStatus.RUNNING]))
        ),
    )

    def __repr__(self) -> str:
        return (
            f"<InsightJob("
            f"job_id={self.job_id}, "
            f"tenant_id={self.tenant_id}, "
            f"status={self.status.value if self.status else None}, "
            f"insights_generated={self.insights_generated}"
            f")>"
        )

    @property
    def is_active(self) -> bool:
        """Check if job is currently active (queued or running)."""
        return self.status in (InsightJobStatus.QUEUED, InsightJobStatus.RUNNING)

    @property
    def is_terminal(self) -> bool:
        """Check if job is in a terminal state."""
        return self.status in (
            InsightJobStatus.SUCCESS,
            InsightJobStatus.FAILED,
            InsightJobStatus.SKIPPED,
        )

    def mark_running(self) -> None:
        """Mark job as running."""
        self.status = InsightJobStatus.RUNNING
        self.started_at = datetime.now(timezone.utc)

    def mark_success(self, insights_generated: int, metadata: dict | None = None) -> None:
        """Mark job as successful with results."""
        self.status = InsightJobStatus.SUCCESS
        self.completed_at = datetime.now(timezone.utc)
        self.insights_generated = insights_generated
        if metadata:
            self.job_metadata = {**(self.job_metadata or {}), **metadata}

    def mark_failed(self, error_message: str) -> None:
        """Mark job as failed with error details."""
        self.status = InsightJobStatus.FAILED
        self.completed_at = datetime.now(timezone.utc)
        self.error_message = error_message[:1000] if error_message else None

    def mark_skipped(self, reason: str) -> None:
        """Mark job as skipped (no data or entitlements)."""
        self.status = InsightJobStatus.SKIPPED
        self.completed_at = datetime.now(timezone.utc)
        self.job_metadata = {**(self.job_metadata or {}), "skip_reason": reason}
