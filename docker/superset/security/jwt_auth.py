"""
Custom Superset Security Manager for JWT-based embedded authentication.

Replaces Superset's default form-based login with JWT token verification.
All access is mediated by embed JWTs generated by the backend EmbedTokenService.

SECURITY PRINCIPLES:
- Superset is NOT the auth system — it only verifies embed tokens
- Every request must carry a valid JWT — deny by default
- JWT claims drive RLS template evaluation (tenant_id, allowed_tenants)
- Superset never sees raw secrets — only signed claims

JWT CLAIMS EXPECTED (from backend EmbedTokenService):
- sub: user_id
- tenant_id: active tenant
- roles: list of role strings
- allowed_tenants: list of accessible tenant IDs
- billing_tier: billing plan tier
- dashboard_id: scoped dashboard
- rls_filter: pre-computed RLS WHERE clause
- iss: issuer ("ai-growth-analytics")
- iat: issued at (unix timestamp)
- exp: expiration (unix timestamp, max 60 min)
"""

import json
import os
import logging
from datetime import datetime, timezone
from typing import Optional

import jwt as pyjwt

logger = logging.getLogger(__name__)

# Maximum allowed token lifetime (seconds) — enforced even if exp is further out
MAX_TOKEN_LIFETIME_SECONDS = 3600  # 60 minutes


# =============================================================================
# Superset-side audit logging (Story 5.1.7)
# =============================================================================
# The Superset container cannot access the backend's PostgreSQL audit table.
# Instead, emit structured JSON to stdout for collection by log aggregator
# (Datadog, CloudWatch, etc.).

def _emit_superset_audit_log(action: str, outcome: str, **extra):
    """Emit structured audit log for Superset-side events.

    Logs as structured JSON for collection by log aggregator.
    The backend audit DB is not accessible from the Superset container.
    """
    audit_entry = {
        "audit_source": "superset",
        "action": action,
        "outcome": outcome,
        "timestamp": datetime.now(timezone.utc).isoformat(),
    }
    audit_entry.update(extra)
    logger.info(
        "AUDIT_EVENT: %s",
        json.dumps(audit_entry),
        extra={"audit": audit_entry},
    )


class EmbedUser:
    """Lightweight user object for JWT-authenticated embed requests.

    Exposes attributes consumed by Superset RLS Jinja templates in rls_rules.py:
    - current_user.tenant_id
    - current_user.allowed_tenants
    - current_user.is_agency_user

    Implements Flask-Login user interface for Superset compatibility.
    """

    def __init__(
        self,
        user_id: str,
        tenant_id: str,
        roles: list[str],
        allowed_tenants: list[str],
        billing_tier: str = "free",
    ):
        self.id = user_id
        self.username = user_id
        self.tenant_id = tenant_id
        self.roles = roles
        self.allowed_tenants = allowed_tenants if allowed_tenants else [tenant_id]
        self.billing_tier = billing_tier
        self.is_agency_user = len(self.allowed_tenants) > 1

        # Flask-Login interface
        self.is_authenticated = True
        self.is_active = True
        self.is_anonymous = False

    def get_id(self) -> str:
        return self.id

    def __repr__(self) -> str:
        if self.is_agency_user:
            return (
                f"EmbedUser(id={self.id}, tenant={self.tenant_id}, "
                f"agency=True, tenants={len(self.allowed_tenants)})"
            )
        return f"EmbedUser(id={self.id}, tenant={self.tenant_id})"


def _get_jwt_secrets() -> list[str]:
    """Get current and previous JWT secrets for key rotation support.

    Returns list of secrets to try (current first, then previous).
    Raises ValueError if no current secret is configured.
    """
    current = os.getenv("SUPERSET_JWT_SECRET_CURRENT")
    if not current:
        raise ValueError(
            "SUPERSET_JWT_SECRET_CURRENT environment variable is required"
        )
    secrets = [current]
    previous = os.getenv("SUPERSET_JWT_SECRET_PREVIOUS")
    if previous:
        secrets.append(previous)
    return secrets


def verify_embed_jwt(token: str) -> Optional[dict]:
    """Verify an embed JWT token, trying current then previous secret.

    Args:
        token: Raw JWT string (without Bearer prefix)

    Returns:
        Decoded payload dict, or None if verification fails.
    """
    secrets = _get_jwt_secrets()

    for secret in secrets:
        try:
            payload = pyjwt.decode(
                token,
                secret,
                algorithms=["HS256"],
                options={
                    "verify_exp": True,
                    "verify_iat": True,
                    "require": ["sub", "tenant_id", "roles", "exp", "iat"],
                },
            )
            # Enforce max token lifetime
            if payload.get("exp", 0) - payload.get("iat", 0) > MAX_TOKEN_LIFETIME_SECONDS:
                logger.warning(
                    "JWT token lifetime exceeds maximum",
                    extra={
                        "user_id": payload.get("sub"),
                        "lifetime_seconds": payload["exp"] - payload["iat"],
                    },
                )
                return None
            return payload
        except pyjwt.ExpiredSignatureError:
            logger.warning("Embed JWT expired")
            return None
        except pyjwt.InvalidTokenError:
            # Try next secret (supports key rotation)
            continue

    logger.warning("Embed JWT failed verification against all secrets")
    return None


def extract_token_from_request() -> Optional[str]:
    """Extract JWT token from a Flask request.

    Checks in order:
    1. Authorization: Bearer <token> header
    2. X-GuestToken header (Superset embedded SDK convention)
    3. ?token= query parameter (initial dashboard load)

    Requires Flask request context.
    """
    from flask import request

    # Authorization header
    auth_header = request.headers.get("Authorization", "")
    if auth_header.startswith("Bearer "):
        return auth_header[7:]

    # Superset embedded SDK header
    guest_token = request.headers.get("X-GuestToken")
    if guest_token:
        return guest_token

    # Query parameter fallback
    return request.args.get("token")


def authenticate_embed_request():
    """Flask before_request handler: authenticate every request via JWT.

    Deny by default — requests without a valid JWT are rejected with 401.
    Health check endpoint is exempted.

    On success, sets Flask globals for RLS template evaluation:
    - g.user: EmbedUser instance (accessed as current_user in Jinja)
    - g.tenant_id: active tenant ID
    - g.allowed_tenants: list of accessible tenant IDs
    - g.rls_filter: pre-computed RLS WHERE clause
    """
    from flask import g, request, abort

    # Allow health check without auth
    if request.path in ("/health", "/health/"):
        return None

    # Allow Superset static assets
    if request.path.startswith("/static/"):
        return None

    token = extract_token_from_request()
    if not token:
        logger.warning(
            "No JWT token in request",
            extra={"path": request.path, "method": request.method},
        )
        _emit_superset_audit_log(
            "analytics.access.denied", "denied",
            reason="missing_token", path=request.path,
        )
        abort(401, description="Authentication required")

    payload = verify_embed_jwt(token)
    if not payload:
        logger.warning(
            "Invalid or expired JWT",
            extra={"path": request.path, "method": request.method},
        )
        _emit_superset_audit_log(
            "analytics.access.denied", "denied",
            reason="invalid_token", path=request.path,
        )
        abort(401, description="Invalid or expired token")

    # Build user from JWT claims
    user = EmbedUser(
        user_id=payload["sub"],
        tenant_id=payload["tenant_id"],
        roles=payload.get("roles", []),
        allowed_tenants=payload.get("allowed_tenants", []),
        billing_tier=payload.get("billing_tier", "free"),
    )

    # Validate tenant_id is in allowed_tenants (runtime guard)
    if user.tenant_id not in user.allowed_tenants:
        logger.warning(
            "JWT tenant_id not in allowed_tenants",
            extra={
                "user_id": user.id,
                "tenant_id": user.tenant_id,
                "allowed_tenants": user.allowed_tenants,
            },
        )
        _emit_superset_audit_log(
            "analytics.cross_tenant.blocked", "denied",
            user_id=user.id, tenant_id=user.tenant_id,
            attempted_tenant_id=user.tenant_id,
        )
        abort(401, description="Invalid tenant context")

    # Set Flask globals for RLS template evaluation
    g.user = user
    g.tenant_id = user.tenant_id
    g.allowed_tenants = user.allowed_tenants
    g.rls_filter = payload.get("rls_filter")
    if not g.rls_filter:
        g.rls_filter = "1=0"  # Safe default if claim is missing

    # Audit: determine event type from request path
    if "/superset/dashboard/" in request.path:
        _emit_superset_audit_log(
            "analytics.dashboard.viewed", "success",
            user_id=user.id, tenant_id=user.tenant_id,
            dashboard_id=payload.get("dashboard_id", ""),
            path=request.path,
        )
    elif "/explore/" in request.path or "/api/v1/chart/" in request.path:
        _emit_superset_audit_log(
            "analytics.explore.accessed", "success",
            user_id=user.id, tenant_id=user.tenant_id,
            path=request.path,
        )

    logger.info(
        "JWT authenticated",
        extra={
            "user_id": user.id,
            "tenant_id": user.tenant_id,
            "is_agency": user.is_agency_user,
            "path": request.path,
        },
    )

    return None
